skill: arrays
version: v1
description: >
  Arrays curriculum focused on installing correct memory, cost, access,
  and boundary mental models. Each slot enforces a specific invariant.

# =========================================================
# SLOT 1 — MEMORY & INDEX MODEL
# =========================================================

slots:
  - slot_id: ARRAY_SLOT_1_MEMORY_MODEL
    mental_install: "Arrays are contiguous memory blocks; index maps directly to address."
    invariant: "address(i) = base_address + i * element_size"
    mastery_signals:
      - Explains contiguous allocation
      - Computes address offsets correctly
      - Describes constant-time index access
    hard_failures:
      - Thinks arrays are linked structures
      - Cannot explain why access is O(1)
      - Confuses index with value

    templates:
      - id: arrays_s1_address_math
        type: explanation
        difficulty: easy
        prompt: |
          An integer array starts at memory address 2000.
          Each integer occupies 4 bytes.
          1) What is the address of arr[5]?
          2) Why does this not depend on array length?
        rubric: >
          Must compute 2020 and explain index arithmetic and constant-time access.
        concepts: [memory_model, indexing, constant_time]

      - id: arrays_s1_index_access
        type: coding
        difficulty: easy
        prompt: "Return the element at index k. Assume valid input."
        language: python
        starter_code: |
          def solve(arr, k):
              pass
        concepts: [indexing, direct_access]

      - id: arrays_s1_remediation_memory
        base_id: arrays_s1_address_math
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Rebuild the memory model of arrays.
          Explain contiguous storage, derive the address formula,
          and show one numeric example.

      - id: arrays_s1_mcq_memory
        type: mcq
        difficulty: easy
        prompt: "Which statement correctly describes how arrays are stored in memory?"
        options:
          - "Each element stores the address of the next element"
          - "Elements are placed randomly and tracked by an index table"
          - "Elements are stored in contiguous memory locations"
          - "Each access requires scanning from the first element"
        correct_answer: 2
        concepts: [memory_model, contiguous_allocation]

      - id: arrays_s1_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          Remember that arrays are like a single block of lockers.
          If you know where locker 0 is, you can jump straight to locker 10
          because they are right next to each other.
        concepts: [memory_model]

# =========================================================
# SLOT 2 — ITERATION & ACCUMULATION
# =========================================================

  - slot_id: ARRAY_SLOT_2_ITERATION
    mental_install: "Arrays are traversed sequentially; state is built across indices."
    invariant: "Every traversal must respect 0 ≤ i < size"
    mastery_signals:
      - Correct loop bounds
      - Handles empty arrays
      - Accumulates without off-by-one errors
    hard_failures:
      - Skips first/last element
      - Fails on empty array
      - Uses length incorrectly

    templates:
      - id: arrays_s2_sum
        type: coding
        difficulty: easy
        prompt: "Return the sum of all elements. Do not use built-in sum()."
        language: python
        starter_code: |
          def solve(arr):
              pass
        concepts: [iteration, accumulation]

      - id: arrays_s2_min_max
        type: coding
        difficulty: easy
        prompt: "Return both the smallest and largest element."
        language: python
        starter_code: |
          def solve(arr):
              pass
        concepts: [iteration, state_tracking]

      - id: arrays_s2_trace_loop
        type: explanation
        difficulty: easy
        prompt: |
          Trace a loop that sums [4, -2, 7].
          Show the value of 'total' after each iteration.
        rubric: "Must show step-by-step state update."
        concepts: [loop_trace, accumulation]

      - id: arrays_s2_remediation_bounds
        base_id: arrays_s2_sum
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Explain how loop bounds work in arrays.
          Trace indices and values for [5,6,7].
          Show what breaks if i <= len(arr).

      - id: arrays_s2_mcq_bounds
        type: mcq
        difficulty: easy
        prompt: "In a zero-indexed array of length N, what are the valid indices?"
        options:
          - "1 to N"
          - "0 to N"
          - "0 to N-1"
          - "1 to N-1"
        correct_answer: 2
        concepts: [iteration, indexing]

      - id: arrays_s2_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          Computers start counting at 0. If you have 5 items, they are at 0, 1, 2, 3, and 4.
          The 'length' (5) is never a valid index for the last item.
        concepts: [indexing]

# =========================================================
# SLOT 3 — SUBARRAY & RANGE THINKING
# =========================================================

  - slot_id: ARRAY_SLOT_3_SUBARRAY
    mental_install: "Subarrays are contiguous ranges defined by boundaries."
    invariant: "A subarray is fully described by [start, end] indices."
    mastery_signals:
      - Correctly identifies subarrays
      - Builds nested loops safely
      - Explains O(n²) generation cost
    hard_failures:
      - Confuses subsequence with subarray
      - Breaks boundaries
      - Skips valid ranges

    templates:
      - id: arrays_s3_list_subarrays
        type: explanation
        difficulty: easy
        prompt: |
          List all subarrays of [1, 2, 3].
          Show them using index ranges.
        rubric: "Must list 6 subarrays and correct ranges."
        concepts: [subarray, boundaries]

      - id: arrays_s3_subarray_sum
        type: coding
        difficulty: medium
        prompt: "Count how many subarrays have sum = k."
        language: python
        starter_code: |
          def solve(arr, k):
              pass
        concepts: [nested_loops, subarray]

      - id: arrays_s3_remediation_ranges
        base_id: arrays_s3_list_subarrays
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Rebuild the idea of a subarray.
          Define what contiguous means.
          List all subarrays of [2,5] using index pairs.

      - id: arrays_s3_mcq_subarray
        type: mcq
        difficulty: easy
        prompt: "Which of the following is NOT a subarray of [10, 20, 30, 40]?"
        options:
          - "[10, 20]"
          - "[20, 30, 40]"
          - "[10, 30]"
          - "[30]"
        correct_answer: 2
        concepts: [subarray, contiguous_ranges]

      - id: arrays_s3_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          A subarray MUST be a continuous slice of the original array.
          If you skip an element (like going from 10 to 30 while skipping 20),
          it's a subsequence, not a subarray.
        concepts: [subarray]

# =========================================================
# SLOT 4 — SHIFTING & STRUCTURAL COST
# =========================================================

  - slot_id: ARRAY_SLOT_4_SHIFTING_MODEL
    mental_install: "Insertion/deletion requires physical shifting of elements."
    invariant: "Number of shifts = number of elements after the position."
    mastery_signals:
      - Manually counts shifts
      - Predicts operation cost
      - Implements shift logic
    hard_failures:
      - Thinks insertion is constant-time everywhere
      - Overwrites data
      - Breaks order invariant

    templates:
      - id: arrays_s4_shift_count
        type: explanation
        difficulty: medium
        prompt: |
          An array of size 7.
          How many elements shift when inserting at:
          a) index 0
          b) index 3
          c) index 7
        rubric: "Must compute shifts and relate to cost."
        concepts: [shifting, cost_model]

      - id: arrays_s4_manual_insert
        type: coding
        difficulty: medium
        prompt: "Insert value x at index i without using insert(). Return new array."
        language: python
        starter_code: |
          def solve(arr, i, x):
              pass
        concepts: [shifting, boundaries]

      - id: arrays_s4_remediation_physical_model
        base_id: arrays_s4_shift_count
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Visualize the array as boxes in memory.
          Show what happens when inserting at the front.
          Count exactly which elements move.

      - id: arrays_s4_mcq_shifting
        type: mcq
        difficulty: medium
        prompt: "If you insert an element at index 0 of an array with N elements, how many existing elements must be shifted?"
        options:
          - "0"
          - "1"
          - "N-1"
          - "N"
        correct_answer: 3
        concepts: [shifting, insertion_cost]

      - id: arrays_s4_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          To make room at the very beginning (index 0), every single existing element
          must move one spot to the right. If there are N elements, N shifts occur.
        concepts: [shifting]

# =========================================================
# SLOT 5 — COST AWARENESS BY POSITION
# =========================================================

  - slot_id: ARRAY_SLOT_5_POSITIONAL_COST
    mental_install: "Operation cost depends on position due to shifting distance."
    invariant: "Cost ∝ number of elements moved"
    mastery_signals:
      - Predicts relative costs
      - Chooses append when possible
      - Avoids middle insertion
    hard_failures:
      - Implements queues with front deletion
      - Cannot justify append efficiency
      - Randomly chooses insertion positions

    templates:
      - id: arrays_s5_cost_analysis
        type: explanation
        difficulty: medium
        prompt: |
          You must support 100k operations.
          Which is cheaper and why:
          frequent appends or frequent front insertions?
        rubric: "Must reference shifting cost and O(n) vs O(1)."
        concepts: [cost_analysis, performance]

      - id: arrays_s5_stack_impl
        type: coding
        difficulty: medium
        prompt: "Implement a stack using only an array."
        language: python
        starter_code: |
          class Stack:
              def __init__(self):
                  self.arr = []
              def push(self, x):
                  pass
              def pop(self):
                  pass
        concepts: [append_pop, cost_awareness]

      - id: arrays_s5_remediation_cost
        base_id: arrays_s5_cost_analysis
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Compare inserting at index 0, middle, and end.
          Explain which elements move and why cost changes.

      - id: arrays_s5_mcq_cost
        type: mcq
        difficulty: medium
        prompt: "Which array operation is generally O(1) in time complexity?"
        options:
          - "Inserting at a random index"
          - "Deleting from the front"
          - "Appending to the end"
          - "Searching for a value"
        correct_answer: 2
        concepts: [complexity, cost_awareness]

      - id: arrays_s5_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          Appending to the end doesn't require moving any other elements (assuming
          there is capacity), so it's a constant time operation. Deleting or 
          inserting elsewhere requires shifts.
        concepts: [appends, complexity]

# =========================================================
# SLOT 6 — RANDOM ACCESS VS SEARCH
# =========================================================

  - slot_id: ARRAY_SLOT_6_ACCESS_VS_SEARCH
    mental_install: "Index lookup is not value search; sortedness trades insertion cost for search speed."
    invariant: "Access O(1); search O(n) unsorted, O(log n) sorted."
    mastery_signals:
      - Distinguishes arr[i] from find(x)
      - Implements binary search correctly
      - Preserves sorted invariant
    hard_failures:
      - Uses binary search on unsorted data
      - Sorts without cost reasoning
      - Cannot explain tradeoff

    templates:
      - id: arrays_s6_binary_search
        type: coding
        difficulty: medium
        prompt: "Implement binary search on a sorted array."
        language: python
        starter_code: |
          def solve(arr, target):
              pass
        concepts: [binary_search, sorted_arrays]

      - id: arrays_s6_tradeoff_explain
        type: explanation
        difficulty: medium
        prompt: |
          Why does a sorted array improve search but worsen insertion?
        rubric: "Must reference binary search and shifting cost."
        concepts: [tradeoffs, invariants]

      - id: arrays_s6_remediation_trace
        base_id: arrays_s6_binary_search
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Trace binary search step by step.
          Show low, mid, high.
          State the invariant at each step.

      - id: arrays_s6_mcq_search_cost
        type: mcq
        difficulty: medium
        prompt: "In an unsorted array of size N, what is the worst-case time complexity to find if a specific value exists?"
        options:
          - "O(1)"
          - "O(log N)"
          - "O(N)"
          - "O(N log N)"
        correct_answer: 2
        concepts: [search_complexity, unsorted_arrays]

      - id: arrays_s6_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          If the data isn't sorted, you might have to check every single element
          one by one to find your target. This leads to linear time complexity, O(N).
        concepts: [linear_search]

# =========================================================
# SLOT 7 — BOUNDARY LITERACY & CAPACITY THINKING
# =========================================================

  - slot_id: ARRAY_SLOT_7_BOUNDARIES
    mental_install: "Edges define correctness; size and capacity are distinct."
    invariant: "0 ≤ index < size ≤ capacity"
    mastery_signals:
      - Handles empty arrays
      - Correct wrap-around
      - Uses size vs capacity
    hard_failures:
      - Off-by-one errors
      - Confuses full vs empty
      - Corrupts circular buffers

    templates:
      - id: arrays_s7_safe_access
        type: coding
        difficulty: medium
        prompt: "Implement safe_get(arr, i) returning None if out of bounds."
        language: python
        starter_code: |
          def safe_get(arr, i):
              pass
        concepts: [bounds_checking]

      - id: arrays_s7_circular_buffer
        type: coding
        difficulty: hard
        prompt: "Implement a circular queue using a fixed-size array."
        language: python
        starter_code: |
          class CircularQueue:
              def __init__(self, k):
                  pass
              def enqueue(self, x):
                  pass
              def dequeue(self):
                  pass
        concepts: [circular_array, capacity_model]

      - id: arrays_s7_remediation_edges
        base_id: arrays_s7_safe_access
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Explain index boundaries using examples.
          Show empty, full, and single-element arrays.
          Demonstrate one off-by-one failure.

      - id: arrays_s7_mcq_bounds_check
        type: mcq
        difficulty: easy
        prompt: "Which check correctly prevents an 'Index Out of Bounds' error for index 'i' in array 'arr'?"
        options:
          - "if i <= len(arr):"
          - "if i < len(arr):"
          - "if i > 0:"
          - "if i < capacity:"
        correct_answer: 1
        concepts: [bounds_checking, indexing]

      - id: arrays_s7_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          The last valid index is always length - 1. Therefore, the index 'i' 
          must be strictly less than the length to be valid.
        concepts: [off_by_one]

# =========================================================
# SLOT 8 — SUBARRAY OPTIMIZATION (ADVANCED)
# =========================================================

  - slot_id: ARRAY_SLOT_8_OPTIMIZATION
    mental_install: "State compression reduces repeated subarray computation."
    invariant: "Each step updates optimal prefix state."
    mastery_signals:
      - Derives Kadane logically
      - Explains why it works
      - Handles all-negative case
    hard_failures:
      - Memorizes formula
      - Breaks on negative arrays
      - Cannot justify transitions

    templates:
      - id: arrays_s8_kadane
        type: coding
        difficulty: hard
        prompt: "Find the maximum subarray sum."
        language: python
        starter_code: |
          def max_subarray(arr):
              pass
        concepts: [prefix_state, dynamic_optimization]

      - id: arrays_s8_kadane_explain
        type: explanation
        difficulty: hard
        prompt: |
          Explain why Kadane’s algorithm works using prefix reasoning.
        rubric: "Must reference local vs global optimal states."
        concepts: [mental_model, optimization]

      - id: arrays_s8_remediation_prefix
        base_id: arrays_s8_kadane
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Define “best subarray ending at i”.
          Derive the transition without formulas.
          Explain why negative prefixes are discarded.

      - id: arrays_s8_mcq_optimization
        type: mcq
        difficulty: hard
        prompt: "In Kadane's algorithm, what do we do if the current subarray sum becomes negative?"
        options:
          - "Keep it and continue adding"
          - "Reset it to zero to start a new potential subarray"
          - "Stop the algorithm and return current max"
          - "Multiply it by -1"
        correct_answer: 1
        concepts: [prefix_state, optimization]

      - id: arrays_s8_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: medium
        prompt: |
          A negative prefix sum will only decrease the total of any future
          elements we add to it. To find the maximum sum, it's always better
          to start fresh (sum = 0) than to carry a negative burden.
        concepts: [prefix_sum]

# =========================================================
# SLOT 9 — PARTITIONING & TWO-POINTERS
# =========================================================

  - slot_id: ARRAY_SLOT_9_PARTITIONING
    mental_install: "Partitioning reorganizes an array into distinct regions in a single pass using multiple pointers."
    invariant: "Three pointers divide the array into categorized regions (e.g., [0..i-1], [i..j], [k..n])."
    mastery_signals:
      - Implements Dutch National Flag algorithm
      - Reorganizes data in O(n) time and O(1) space
      - Handles boundary pointer crossings
    hard_failures:
      - Uses O(n) extra space
      - Swaps incorrectly, causing infinite loops
      - Requires more than one pass

    templates:
      - id: arrays_s9_sort_colors
        type: coding
        difficulty: medium
        prompt: "Given an array with n objects colored red, white, or blue (0, 1, 2), sort them in-place."
        language: python
        starter_code: |
          def sortColors(nums):
              pass
        concepts: [partitioning, two_pointers, in_place]

      - id: arrays_s9_remediation_partition
        base_id: arrays_s9_sort_colors
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Visualize the three regions. 
          Explain why 'mid' is the worker pointer and what happens when it 
          swaps with 'low' vs 'high'.
        concepts: [pointer_logic]

      - id: arrays_s9_mcq_partition_complexity
        type: mcq
        difficulty: medium
        prompt: "What is the space complexity of the Dutch National Flag algorithm to sort three categories?"
        options:
          - "O(1)"
          - "O(log N)"
          - "O(N)"
          - "O(N^2)"
        correct_answer: 0
        concepts: [space_complexity, in_place]

      - id: arrays_s9_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          Because we only use a few pointers (low, mid, high) to swap elements 
          within the existing array, we don't need any new arrays. 
          This is called 'In-Place' and uses constant (O(1)) space.
        concepts: [memory_optimization]

# =========================================================
# SLOT 10 — INTERVALS & SORTING INVARIANTS
# =========================================================

  - slot_id: ARRAY_SLOT_10_INTERVALS
    mental_install: "Intervals are range-based subarrays that can be merged if they overlap."
    invariant: "If cur_interval.start <= prev_interval.end, they must be merged."
    mastery_signals:
      - Sorts by start time before processing
      - Correctly calculates merged range boundaries
      - Handles non-overlapping jumps
    hard_failures:
      - Attempts to merge without sorting first
      - Incorrectly calculates end bound (uses cur.end instead of max(prev.end, cur.end))
      - Loses interval data during merging

    templates:
      - id: arrays_s10_merge_intervals
        type: coding
        difficulty: medium
        prompt: "Merge all overlapping intervals in a list."
        language: python
        starter_code: |
          def merge(intervals):
              pass
        concepts: [intervals, sorting, range_logic]

      - id: arrays_s10_remediation_merge
        base_id: arrays_s10_merge_intervals
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Draw two overlapping intervals [1, 5] and [2, 6]. 
          Show why the new interval is [1, 6]. 
          Explain why sorting by 'start' makes the logic possible in one pass.
        concepts: [overlap_detection]

      - id: arrays_s10_mcq_interval_sort
        type: mcq
        difficulty: medium
        prompt: "Why is it usually necessary to sort intervals by their start time before merging?"
        options:
          - "To reduce time complexity to O(1)"
          - "To ensure that overlapping intervals are adjacent in the list"
          - "Because intervals cannot be merged otherwise"
          - "To change the space complexity"
        correct_answer: 1
        concepts: [sorting_invariants]

      - id: arrays_s10_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: medium
        prompt: |
          If we don't sort, intervals that overlap could be at opposite ends of 
          the list. Sorting brings potentially overlapping ranges right next 
          to each other, allowing us to merge them in a single scan.
        concepts: [spatial_locality]

# =========================================================
# SLOT 11 — 2D ARRAYS (MATRICES)
# =========================================================

  - slot_id: ARRAY_SLOT_11_MATRICES
    mental_install: "2D arrays map 2D coordinates (row, col) to 1D memory layout."
    invariant: "A coordinate (r, c) in a matrix with C columns is at index r * C + c in memory."
    mastery_signals:
      - Correctly maps row/column indices
      - Implements non-standard traversals (spiral, diagonal)
      - Transposes or rotates in-place
    hard_failures:
      - Swaps row and column indices (r[c] vs c[r])
      - Out-of-bounds on row/column boundaries
      - Inefficiently copies the matrix when in-place is possible

    templates:
      - id: arrays_s11_spiral_matrix
        type: coding
        difficulty: hard
        prompt: "Return all elements of an m x n matrix in spiral order."
        language: python
        starter_code: |
          def spiralOrder(matrix):
              pass
        concepts: [matrix_traversal, boundary_control]

      - id: arrays_s11_remediation_matrix
        base_id: arrays_s11_spiral_matrix
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Explain the 'Four Boundary' model. 
          How do top, bottom, left, and right pointers narrow down the search space?
        concepts: [coordinate_mapping]

      - id: arrays_s11_mcq_matrix_index
        type: mcq
        difficulty: easy
        prompt: "In a 2D matrix 'arr', what does `arr[2][3]` typically represent?"
        options:
          - "Row 3, Column 2"
          - "Row 2, Column 3"
          - "The sum of 2 and 3"
          - "A subarray of length 6"
        correct_answer: 1
        concepts: [indexing, syntax]

      - id: arrays_s11_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          In the notation `matrix[r][c]`, the first index selects the nested 
          list (the row), and the second index selects the item within that 
          list (the column).
        concepts: [nested_traversal]

# =========================================================
# SLOT 12 — ROTATION INVARIANTS
# =========================================================

  - slot_id: ARRAY_SLOT_12_ROTATION
    mental_install: "Rotated sorted arrays maintain sorted properties in segments."
    invariant: "At any split point in a rotated sorted array, at least one half is always sorted."
    mastery_signals:
      - Identifies sorted halves in binary search
      - Finds the pivot/inflection point in O(log n)
      - Adapts binary search targets based on segments
    hard_failures:
      - Uses standard binary search without rotation logic
      - Reverts to linear search O(n)
      - Fails on arrays with duplicates

    templates:
      - id: arrays_s12_rotated_search
        type: coding
        difficulty: hard
        prompt: "Find the index of a target in a rotated sorted array."
        language: python
        starter_code: |
          def search(nums, target):
              pass
        concepts: [binary_search, rotation, invariants]

      - id: arrays_s12_remediation_rotation
        base_id: arrays_s12_rotated_search
        type: explanation
        variant: remediation
        strategy: explanation
        prompt: |
          Explain the 'One Sorted Half' rule. 
          Why can we always discard half of a rotated array even if it's not fully sorted?
        concepts: [logarithmic_logic]

      - id: arrays_s12_mcq_rotation_property
        type: mcq
        difficulty: hard
        prompt: "What is the key property we use to binary search in a rotated sorted array?"
        options:
          - "The whole array is still sorted"
          - "At least one half (left or right) of the search space is always sorted"
          - "The target is always in the smaller half"
          - "The middle element is always the pivot"
        correct_answer: 1
        concepts: [invariants, search_logic]

      - id: arrays_s12_remediation_mcq
        type: explanation
        variant: remediation
        difficulty: medium
        prompt: |
          Even if an array is rotated, like [4, 5, 6, 7, 0, 1, 2], picking any 
          middle element will always leave either the left side or the right 
          side perfectly ordered. We search the ordered side first!
        concepts: [partitioned_search]
